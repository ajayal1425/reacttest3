<html>
<head>
	<title>React test 4
	</title>
</head>
	<body>
		<pre>
			1. What is the output of below code?
        import { useState } from 'react';  export default function Counter() { 
              const [counter, setCounter] = useState(5);    return ( <>     
                < span>{counter}< /span>       < button onClick={ ( ) => {      
                       setCounter(counter + 5);         setCounter(counter + 5);    
                            alert(counter);         setCounter(counter + 5);       
                              setCounter(counter + 5);       }}>Increment< /button>        ) } 
                              
        output:5   alert:5  when to click alert btn=>ok,then count value is increse ,the dom is update
        ex:   10   alert :10 
                    
        2.What will be the output of the below code if the button is clicked:

        function App() { 
         const [count, setCount] = useState(0); 
         useEffect(() => {
         console.log("Component rendered successfully");   }, []); 
         return (
         < div> 
           	< button onClick={ ( ) => setCount(count + 1)}>Click me< /button>
           	< p>You clicked {count} times< /p>
     	< /div>   ); }      
        
        output:the output will be 1.
        
        3.How do you create forms in React?    
        React uses forms to allow users to interact with the web page.
         In React, form data is usually handled by the components.
          When the data is handled by the components, all the data is
           stored in the component state. You can control changes by adding
            event handlers in the onChange attribute and that event handler
             will be used to update the state of the variable.
        Ex:< form>
            < label>Input Value:< /label>
            < input  type="text"  value={inputValue} onChange={handleChange} />
            < /form>
            < p>Input Value: {inputValue}< /p> 
            
        4. Explain lifecycle methods.       
        In React, components have a lifecycle that consists of different phases. Each phase has a set of lifecycle methods that are called at specific points in the component's lifecycle. These methods allow you to control the component's behavior and
		perform specific actions at different stages of its lifecycle.
		A component's lifecycle has three main phases: the Mounting Phase, the Updating Phase, and the Unmounting Phase.
		The Mounting Phase begins when a component is first created and inserted into the DOM.
		The Updating Phase occurs when a component's state or props change. And the Unmounting Phase occurs when a component is removed from the DOM.    
		
		The componentDidMount() lifecycle method:
The componentDidMount() method is called once the component has been mounted into the DOM. It is typically used to set up any necessary event listeners or timers, perform any necessary API calls or data fetching, and perform other initialization tasks that require access to the browser's DOM API.

Here's an example:

import React from 'react';
import ReactDOM from 'react-dom';
class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritefood: "rice"};
  }
  componentDidMount() {
    setTimeout(() => {
      this.setState({favoritefood: "pizza"})
    }, 1000)
  }
  render() {
    return (
      <h1>My Favorite Food is {this.state.favoritefood}</h1>
    );
  }
}

ReactDOM.render(<Header />, document.getElementById('root')); 

The shouldComponentUpdate() lifecycle method:
The shouldComponentUpdate()  method is called before a component is updated. It takes two arguments: nextProps and nextState. This method returns a boolean value that determines whether the component should update or not. If this method returns true, the component will update, and if it returns false, the component will not update.

Here's an example of how to use shouldComponentUpdate():

import React, { Component } from 'react';
import ReactDOM from 'react-dom';

class Header extends Component {
  constructor(props) {
    super(props);
    this.state = { favoriteFood: 'rice' };
  }

  shouldComponentUpdate(nextProps, nextState) {
    // Only re-render if the favoriteFood state has changed
    return this.state.favoriteFood !== nextState.favoriteFood;
  }

  changeFood = () => {
    this.setState({ favoriteFood: 'Pizza' });
  }

  render() {
    return (
      <div>
        <h1>My Favorite Food is {this.state.favoriteFood}</h1>
        <button type="button" onClick={this.changeFood}>Change food</button>
      </div>
    );
  }
}

ReactDOM.render(<Header />, document.getElementById('root'));

The componentDidUpdate lifecycle method
The componentDidUpdate() method is a lifecycle method in React that is called after a component has been updated and re-rendered. It is useful for performing side effects or additional operations when the component's props or state have changed.

Here's an example of how to use the componentDidUpdate() method:

import React, { Component } from 'react';

class ExampleComponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.count !== this.state.count) {
      console.log('Count has been updated:', this.state.count);
    }
  }

  handleClick() {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={() => this.handleClick()}>Increment</button>
      </div>
    );
  }
}

export default ExampleComponent;

The componentWillUnmount() lifecycle method:
During the unmounting phase, React calls the following lifecycle methods in order:

componentWillUnmount(): This method is called just before the component is removed from the DOM. It allows you to perform any necessary cleanup, such as canceling timers, removing event listeners, or clearing any data structures that were set up during the mounting phase.
After componentWillUnmount() is called, the component is removed from the DOM and all of its state and props are destroyed.


        5.Can web browsers read JSX directly?  
        JSX isn't directly supported by browsers, requiring conversion
         by tools like Babel to transform JSX into valid JavaScript.
          This transpilation ensures browsers can interpret and execute
           the JSX-embedded code in React applications.

        6.How Do You Handle Forms in React?
        In React, form data is usually handled by the components. 
        When the data is handled by the components, all the data is
         stored in the component state. You can control changes by
          adding event handlers in the onChange attribute.
        
        7.What is virtual dom in the react?    
        Instead of manipulating the browser's DOM directly,
         React creates a virtual DOM in memory, where it does 
         all the necessary manipulating, before making the changes 
         in the browser DOM. React only changes what needs to be changed!
         
        8.In React, Why Is There a Need for Using Keys in Lists?
        Keys help React identify which items have changed (added/removed/re-ordered).
         To give a unique identity to every element inside the array, a key is required.

        To better understand this, let  s refactor the code snippet we saw earlier, 
        to now include keys.

        
        9.What Is the Difference Between State and Props in React? 
        Props are used to pass data from a parent component to a child component,
         while state is used to manage data within a component. Props are immutable
          and cannot be changed within a component, while state is mutable and can
         be updated using the setState function.
		</pre>
	</body>
</html>